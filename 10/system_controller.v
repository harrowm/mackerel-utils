// -----------------------------------------------------
// Generated by convert.sh from system-controller.qsf
// Don't edit this file, edit the project files instead 
// -----------------------------------------------------

module clock_gen(
    input CLK_IN,
    output CLK_OUT
);

// Generate CPU clock from source oscillator
reg clk_buf = 1'b0;
assign CLK_OUT = clk_buf;	// Divide source clock by 2 to get CPU clock
always @(posedge CLK_IN) clk_buf <= clk_buf + 1'b1;

endmodule
// BOOT signal is active HIGH indicated the first four bus cycles after reset have completed
module boot_signal(
    input RESET_n,
    input AS_n,
    output reg BOOT = 1'b0
);

localparam BOOT_CYCLE_MAX = 4;

reg [2:0] bus_cycles = 0;

always @(posedge AS_n) begin
	if (~RESET_n) begin 
		bus_cycles = 0;
		BOOT <= 1'b0;
	end
	else begin
		if (~BOOT) begin
			bus_cycles <= bus_cycles + 3'b1;
			if (bus_cycles == BOOT_CYCLE_MAX) BOOT <= 1'b1;
		end
	end
end

endmodule
module system_controller(
	input CLK,
	input RST_n,

	output CLK_CPU,
	
	output IPL0_n, IPL1_n, IPL2_n,
	
	output DTACK_n,
	
	output reg VPA_n,
	
	input [7:0] DATA,
	
	input [23:14] ADDR_H,
	input [3:1] ADDR_L,
	
	input AS_n, UDS_n, LDS_n, RW,
	
	input FC0, FC1, FC2,
	
	output CS_ROM0_n, CS_ROM1_n,
	output CS_SRAM0_n, CS_SRAM1_n,
	
	output CS_EXP_n,
	input IRQ_EXP_n,
	input DTACK_EXP_n,
	output IACK_EXP_n,
	
	output CS_DUART_n,
	input IRQ_DUART_n,
	input DTACK_DUART_n,
	output IACK_DUART_n,
	
	output CS_DRAM_n,
	input DTACK_DRAM_n,
	
	input IDE_INT,
	output CS_IDE0_n,
	output CS_IDE1_n,
	input IDE_RDY,
	output IDE_RD_n,
	output IDE_WR_n,
	output IDE_BUF_n,
	
	output [3:0] GPIO
);

// Source oscillator frequency
localparam OSC_FREQ_HZ = 20000000;
// CPU frequency (half the oscillator frequency)
localparam CPU_FREQ_HZ = OSC_FREQ_HZ / 2;
// Frequency of the periodic timer interrupt
localparam TIMER_FREQ_HZ = 50;
// CPU cycles between timer interrupts
localparam TIMER_DELAY_CYCLES = CPU_FREQ_HZ / TIMER_FREQ_HZ;

// Unused signals
assign IACK_EXP_n = 1;
assign CS_EXP_n = 1'b1;

assign GPIO = 4'b0;

// Reconstruct the full address bus
wire [24:0] ADDR_FULL = {ADDR_H, 10'b0, ADDR_L, 1'b0};

// CPU is responding to an interrupt request
wire IACK_n = ~(FC0 && FC1 && FC2);

assign IACK_DUART_n = ~(~IACK_n && ~AS_n && ADDR_L[3:1] == 3'd5);

// DTACK from DUART
//wire DTACK0 = ((~CS_DUART_n || ~IACK_DUART_n) && DTACK_DUART_n);
wire DTACK0 = 1'b0;	// DUART DTACK is always low anyway?
// DTACK from DRAM
wire DTACK1 = (~CS_DRAM_n && DTACK_DRAM_n);
// DTACK from IDE
//wire DTACK2 = ((~CS_IDE0_n || ~CS_IDE1_n) && ~IDE_RDY);
wire DTACK2 = 1'b0;
// DTACK to CPU
assign DTACK_n = DTACK0 || DTACK1 || DTACK2 || ~VPA_n;	// NOTE: DTACK and VPA cannot be LOW at the same time

// BOOT signal generation
wire BOOT;
boot_signal bs1(RST_n, AS_n, BOOT);

// Generate CPU clock from source oscillator
clock_gen cg1(CLK, CLK_CPU);

// Encode interrupt sources to the CPU's IPL pins
irq_encoder ie1(
	.irq1(0),
	.irq2(0),
	.irq3(IDE_INT),
	.irq4(0),
	.irq5(~IRQ_DUART_n),
	.irq6(IRQ_TIMER),
	.irq7(0),
	.ipl0_n(IPL0_n),
	.ipl1_n(IPL1_n),
	.ipl2_n(IPL2_n)
);

reg[23:0] clock_cycles = 0;
reg IRQ_TIMER = 0;

always @(posedge CLK_CPU) begin
	clock_cycles <= clock_cycles + 1'b1;
	
	if (~RST_n) begin
		clock_cycles <= 24'b0;
	end
	else if (clock_cycles == TIMER_DELAY_CYCLES) begin
		IRQ_TIMER <= 1;
		clock_cycles <= 24'b0;
	end
	
	// Autovector the non-DUART interrupts
	if (~IACK_n && IACK_DUART_n && ~AS_n) begin
		VPA_n <= 1'b0;
		IRQ_TIMER <= 0;
	end
	else VPA_n <= 1'b1;
end

//================================//
// Address Decoding
//================================//

// ROM at 0xF00000 - 0xFF4000 (0x000000 on BOOT)
wire ROM_EN = ~BOOT || (IACK_n && ADDR_FULL >= 24'hF00000 && ADDR_FULL < 24'hFF4000);
assign CS_ROM0_n = ~(~AS_n && ~LDS_n && ROM_EN);
assign CS_ROM1_n = ~(~AS_n && ~UDS_n && ROM_EN);

// SRAM enabled at 0xE00000 - 0xF00000 (1 MB)
wire RAM_EN = BOOT && IACK_n && ADDR_FULL >= 24'hE00000 && ADDR_FULL < 24'hF00000;
assign CS_SRAM0_n = ~(~AS_n && ~LDS_n && RAM_EN);
assign CS_SRAM1_n = ~(~AS_n && ~UDS_n && RAM_EN);

// DRAM at 0x000000 - 0xE00000 (14 MB)
assign CS_DRAM_n = ~(BOOT && IACK_n && ADDR_FULL < 24'hE00000);

// DUART at 0xFF8000
assign CS_DUART_n = ~(BOOT && IACK_n && ~LDS_n && ADDR_FULL >= 24'hFF8000 && ADDR_FULL < 24'hFFC000);

// IDE at 0xFF4000 and 0xFFC000
assign CS_IDE0_n = ~(BOOT && IACK_n && ADDR_FULL >= 24'hFFC000);
assign CS_IDE1_n = ~(BOOT && IACK_n && ADDR_FULL >= 24'hFF4000 && ADDR_FULL < 24'hFF8000);
assign IDE_BUF_n = ~(~CS_IDE0_n || ~CS_IDE1_n);
assign IDE_RD_n = ~(RW && ~AS_n && ~UDS_n);
assign IDE_WR_n = ~(~RW && ~AS_n && ~UDS_n);

endmodule
// Priority encode 7 interrupt sources (active high) to three interrupt priority level pins (active low)

module irq_encoder(
	input irq1,
	input irq2,
	input irq3,
	input irq4,
	input irq5,
	input irq6,
	input irq7,
	output reg ipl0_n,
	output reg ipl1_n,
	output reg ipl2_n
);

always @(*) begin
	if (irq7) begin
		ipl0_n = 0;
		ipl1_n = 0;
		ipl2_n = 0;
	end
	else if (irq6) begin
		ipl0_n = 1;
		ipl1_n = 0;
		ipl2_n = 0;
	end
	else if (irq5) begin
		ipl0_n = 0;
		ipl1_n = 1;
		ipl2_n = 0;
	end
	else if (irq4) begin
		ipl0_n = 1;
		ipl1_n = 1;
		ipl2_n = 0;
	end
	else if (irq3) begin
		ipl0_n = 0;
		ipl1_n = 0;
		ipl2_n = 1;
	end
	else if (irq2) begin
		ipl0_n = 1;
		ipl1_n = 0;
		ipl2_n = 1;
	end
	else if (irq1) begin
		ipl0_n = 0;
		ipl1_n = 1;
		ipl2_n = 1;
	end
	else begin
		ipl0_n = 1;
		ipl1_n = 1;
		ipl2_n = 1;
	end
end

endmodule




// -----------------------------------------------------
// Chip and pin assignments
// -----------------------------------------------------
//PIN: CHIP "system-controller" ASSIGNED TO A PLCC84
//PIN: 83 CLK
//PIN: 25 GPIO[2]
//PIN: 27 GPIO[3]
//PIN: 5 ADDR_H[23]
//PIN: 6 ADDR_H[22]
//PIN: 8 ADDR_H[21]
//PIN: 9 ADDR_H[20]
//PIN: 10 ADDR_H[19]
//PIN: 11 ADDR_H[18]
//PIN: 12 ADDR_H[17]
//PIN: 15 ADDR_H[16]
//PIN: 16 ADDR_H[15]
//PIN: 17 ADDR_H[14]
//PIN: 52 CLK_CPU
//PIN: 58 DATA[7]
//PIN: 61 DATA[6]
//PIN: 64 DATA[5]
//PIN: 70 DATA[4]
//PIN: 69 DATA[3]
//PIN: 68 DATA[2]
//PIN: 67 DATA[1]
//PIN: 65 DATA[0]
//PIN: 40 FC0
//PIN: 41 FC1
//PIN: 44 FC2
//PIN: 56 RW
//PIN: 18 ADDR_L[1]
//PIN: 20 ADDR_L[2]
//PIN: 21 ADDR_L[3]
//PIN: 33 IDE_INT
//PIN: 35 IDE_RDY
//PIN: 4 RST_n
//PIN: 63 AS_n
//PIN: 51 DTACK_n
//PIN: 46 IPL0_n
//PIN: 45 IPL1_n
//PIN: 48 IPL2_n
//PIN: 49 VPA_n
//PIN: 60 UDS_n
//PIN: 57 LDS_n
//PIN: 73 CS_ROM0_n
//PIN: 75 CS_ROM1_n
//PIN: 74 CS_SRAM1_n
//PIN: 76 CS_SRAM0_n
//PIN: 54 CS_DRAM_n
//PIN: 55 DTACK_DRAM_n
//PIN: 28 CS_EXP_n
//PIN: 30 DTACK_EXP_n
//PIN: 81 DTACK_DUART_n
//PIN: 79 CS_DUART_n
//PIN: 80 IACK_DUART_n
//PIN: 77 IRQ_DUART_n
//PIN: 31 IACK_EXP_n
//PIN: 29 IRQ_EXP_n
//PIN: 39 IDE_BUF_n
//PIN: 34 CS_IDE0_n
//PIN: 36 IDE_RD_n
//PIN: 37 IDE_WR_n
//PIN: 50 CS_IDE1_n
//PIN: 22 GPIO[0]
//PIN: 24 GPIO[1]